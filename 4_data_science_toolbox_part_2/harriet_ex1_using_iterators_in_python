#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Sat Dec 29 17:04:09 2018

@author: harriet
"""

#### iterators and iterables
# an iterable is an object that can return an iterator
# an iterator is an object that keeps state and produces the next value when you call next() on it


#### iterating over iterables

# Create a list of strings: flash
flash = ['jay garrick', 'barry allen', 'wally west', 'bart allen']

# Print each list item in flash using a for loop
for person in flash:
    print(person)


# Create an iterator for flash: superspeed
superspeed=iter(flash)

# Print each item from the iterator
print(next(superspeed))
print(next(superspeed))
print(next(superspeed))
print(next(superspeed))


#### using range() to iterate over iterables

# Create an iterator for range(3): small_value
small_value = iter(range(3))

# Print the values in small_value
print(next(small_value))
print(next(small_value))
print(next(small_value))

# Loop over range(3) and print the values
for i in range(3):
    print (i)


# Create an iterator for range(10 ** 100): googol
googol = iter(range(10**100))

# Print the first 5 values from googol
print(next(googol))
print(next(googol))
print(next(googol))
print(next(googol))
print(next(googol))


#### iterators as function arguments

# Create a range object: values
values = range(10, 21)

# Print the range object
print(values)

# Create a list of integers: values_list
values_list = list(values)

# Print values_list
print(values_list)

# Get the sum of values: values_sum
values_sum = sum(range(10,21))

# Print values_sum
print(values_sum)



#### using enumerate

#enumerate() returns an enumerate object that produces a sequence of tuples, and each of the tuples is an index-value pair.

# by default enumerate begins the index at 0
# you can add the argument start=1 (or e.g. 10) to change this

# Create a list of strings: mutants
mutants = ['charles xavier', 
            'bobby drake', 
            'kurt wagner', 
            'max eisenhardt', 
            'kitty pryde']

# Create a list of tuples: mutant_list
mutant_list = list(enumerate(mutants))

# Print the list of tuples
print(mutant_list)

# Unpack and print the tuple pairs
for index1, value1 in enumerate(mutants):
    print(index1, value1)

# Change the start index
for index2, value2 in enumerate(mutants, start=1):
    print(index2, value2)


#### using zip

#zip() takes any number of iterables and returns a zip object that is an iterator of tuples. 
#If you wanted to print the values of a zip object, you can convert it into a list and then print it. 
#Printing just a zip object will not return the values unless you unpack it first. 
#
#Three lists of strings are pre-loaded: mutants, aliases, and powers. 
#First, you will use list() and zip() on these lists to generate a list of tuples. 
#Then, you will create a zip object using zip(). Finally, you will unpack this zip object in a for loop to print the values in each tuple. 
#Observe the different output generated by printing the list of tuples, then the zip object, and finally, the tuple values in the for loop.
    
# Create a list of tuples: mutant_data
mutant_data = list(zip(mutants, aliases, powers))

# Print the list of tuples
print(mutant_data)

# Create a zip object using the three lists: mutant_zip
mutant_zip = zip(mutants, aliases, powers)

# Print the zip object
print(mutant_zip)

# Unpack the zip object and print the tuple values
for value1, value2, value3 in mutant_zip:
   print(value1, value2, value3)



#### zipping and unzipping
   
#Let's play around with zip() a little more. 
#There is no unzip function for doing the reverse of what zip() does. 
#We can, however, reverse what has been zipped together by using zip() with a little help from *! 
#* unpacks an iterable such as a list or a tuple into positional arguments in a function call.
#
#In this exercise, you will use * in a call to zip() to unpack the tuples produced by zip().
#
#Two tuples of strings, mutants and powers have been pre-loaded.
   
   
# Create a zip object from mutants and powers: z1
z1 = zip(mutants, powers)

# Print the tuples in z1 by unpacking with *
print(*z1)

# Re-create a zip object from mutants and powers: z1
z1 = zip(mutants, powers)

# 'Unzip' the tuples in z1 by unpacking with * and zip(): result1, result2
result1, result2 = zip(*z1)

# Check if unpacked tuples are equivalent to original tuples
print(result1 == mutants)
print(result2 == powers)


#### chunksize to iterate over chunks of data

#Initialize an empty dictionary counts_dict for storing the results of processing the Twitter data.
#Iterate over the 'tweets.csv' file by using a for loop. Use the loop variable chunk and iterate over the call to pd.read_csv() with a chunksize of 10.
#In the inner loop, iterate over the column 'lang' in chunk by using a for loop. Use the loop variable entry.

# Initialize an empty dictionary: counts_dict
counts_dict={}

# Iterate over the file chunk by chunk
for chunk in pd.read_csv('tweets.csv', chunksize=10):

    # Iterate over the column in DataFrame
    for entry in chunk['lang']:
        if entry in counts_dict.keys():
            counts_dict[entry] += 1
        else:
            counts_dict[entry] = 1

# Print the populated dictionary
print(counts_dict)


##### make this a function

#Define the function count_entries(), which has 3 parameters. 
#The first parameter is csv_file for the filename, the second is c_size for the chunk size, and the last is colname for the column name.
#Iterate over the file in csv_file file by using a for loop. Use the loop variable chunk and iterate over the call to pd.read_csv(), passing c_size to chunksize.
#In the inner loop, iterate over the column given by colname in chunk by using a for loop. Use the loop variable entry.
#Call the count_entries() function by passing to it the filename 'tweets.csv', the size of chunks 10, and the name of the column to count, 'lang'. 
#Assign the result of the call to the variable result_counts.

# Define count_entries()
def count_entries(csv_file, c_size, col_name):
    """Return a dictionary with counts of
    occurrences as value for each key."""
    
    # Initialize an empty dictionary: counts_dict
    counts_dict = {}

    # Iterate over the file chunk by chunk
    for chunk in pd.read_csv(csv_file, chunksize=c_size):

        # Iterate over the column in DataFrame
        for entry in chunk[col_name]:
            if entry in counts_dict.keys():
                counts_dict[entry] += 1
            else:
                counts_dict[entry] = 1

    # Return counts_dict
    return counts_dict

# Call count_entries(): result_counts
result_counts = count_entries('tweets.csv', c_size=10, col_name='lang')

# Print result_counts
print(result_counts)


#### 